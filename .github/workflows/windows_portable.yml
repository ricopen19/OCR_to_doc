name: windows-portable

on:
  workflow_dispatch:
    inputs:
      with_runtime:
        description: "Bundle Python runtime (resources/python) into the portable zip (large)"
        type: boolean
        default: false
  push:
    tags:
      - "v*"

jobs:
  build:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ui/package-lock.json

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Build Tauri (Windows)
        working-directory: ui
        run: |
          npm ci --legacy-peer-deps
          npm run tauri:build

      - name: Assemble portable directory
        run: |
          $ErrorActionPreference = "Stop"

          $outRoot = Join-Path $PWD "dist-portable"
          $appDir = Join-Path $outRoot "ocr-to-doc"
          New-Item -ItemType Directory -Force -Path $appDir | Out-Null

          # Pick the built exe
          $releaseDir = Join-Path $PWD "ui/src-tauri/target/release"
          if (-not (Test-Path $releaseDir)) { throw "release dir not found: $releaseDir" }
          $exeCandidates = Get-ChildItem -Path $releaseDir -Filter "*.exe" -File
          if (-not $exeCandidates) { throw "no exe found in $releaseDir" }

          $picked = $exeCandidates | Where-Object { $_.Name -eq "ocr-to-doc.exe" } | Select-Object -First 1
          if (-not $picked) { $picked = $exeCandidates | Select-Object -First 1 }

          Copy-Item -Force -Path $picked.FullName -Destination (Join-Path $appDir "ocr-to-doc.exe")

          # Copy side-by-side dlls if any (some builds need these next to the exe)
          Get-ChildItem -Path $releaseDir -Filter "*.dll" -File | ForEach-Object {
            Copy-Item -Force -Path $_.FullName -Destination $appDir
          }

          # App configs (UI settings)
          if (Test-Path "configs") {
            Copy-Item -Recurse -Force -Path "configs" -Destination $appDir
          }

          # Python scripts are placed under resources/py to reduce user accidents
          $pyDir = Join-Path $appDir "resources/py"
          New-Item -ItemType Directory -Force -Path $pyDir | Out-Null
          Copy-Item -Force -Path "*.py" -Destination $pyDir

          # Templates used by markdown_cleanup.py
          @("formatting_templates.json","formula_templates.json","icon_config.json") | ForEach-Object {
            if (Test-Path $_) { Copy-Item -Force -Path $_ -Destination $pyDir }
          }

          # Python-side configs (icon profiles)
          $pyConfigsDir = Join-Path $pyDir "configs"
          New-Item -ItemType Directory -Force -Path $pyConfigsDir | Out-Null
          if (Test-Path "configs/icon_profiles") {
            Copy-Item -Recurse -Force -Path "configs/icon_profiles" -Destination $pyConfigsDir
          }

          # Poppler is bundled (PDF rendering)
          if (Test-Path "poppler") {
            Copy-Item -Recurse -Force -Path "poppler" -Destination $pyDir
          } else {
            throw "poppler directory not found at repo root"
          }

      - name: (Optional) Setup Python for runtime bundling
        if: ${{ github.event_name == 'push' || github.event.inputs.with_runtime == 'true' }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: (Optional) Bundle portable Python runtime
        if: ${{ github.event_name == 'push' || github.event.inputs.with_runtime == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"

          # 1) Copy Python runtime itself into the portable directory (no user PATH required)
          $appDir = Join-Path $PWD "dist-portable/ocr-to-doc"
          $runtimeDir = Join-Path $appDir "resources/python"
          New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null

          $pyExe = (python -c "import sys; print(sys.executable)").Trim()
          if (-not (Test-Path $pyExe)) { throw "python.exe not found: $pyExe" }
          $pyHome = Split-Path -Parent $pyExe

          Copy-Item -Recurse -Force -Path "$pyHome/*" -Destination $runtimeDir

          # 2) Generate requirements from pyproject.toml (avoid poetry.lock mismatch issues)
          $py = @'
          import re
          import tomllib
          from pathlib import Path
          
          with open("pyproject.toml", "rb") as f:
              data = tomllib.load(f)
          
          deps = data.get("project", {}).get("dependencies", [])
          if not deps:
              raise SystemExit("no dependencies found in [project].dependencies")
          
          def normalize(dep: str) -> str:
              m = re.match(r"^([^ ]+)(?: \\(([^)]+)\\))?$", dep.strip())
              if not m:
                  return dep.strip()
              name = m.group(1)
              spec = m.group(2)
              return f"{name}{spec}" if spec else name
          
          seen = set()
          out = []
          for d in deps:
              n = normalize(d)
              if n not in seen:
                  seen.add(n)
                  out.append(n)
          
          Path("requirements-runtime.txt").write_text("\\n".join(out) + "\\n", encoding="utf-8")
          print("wrote requirements-runtime.txt with", len(out), "lines")
          '@
          python -c $py

          # 3) Install runtime dependencies into the bundled Python
          $runtimePy = Join-Path $runtimeDir "python.exe"
          if (-not (Test-Path $runtimePy)) { throw "bundled python.exe not found: $runtimePy" }
          & $runtimePy -m ensurepip --upgrade
          & $runtimePy -m pip install --upgrade pip
          & $runtimePy -m pip install -r requirements-runtime.txt

          # Quick sanity checks for optional deps used by the app
          & $runtimePy -c "import latex2mathml; import yomitoku; import markitdown; print('runtime imports ok')"

      - name: Prepare fixture
        if: ${{ github.event_name == 'push' || github.event.inputs.with_runtime == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          $appDir = Join-Path $PWD "dist-portable/ocr-to-doc"
          $fixtureDir = Join-Path $appDir "resources/fixtures"
          New-Item -ItemType Directory -Force -Path $fixtureDir | Out-Null

          $b64 = (Get-Content "tests/fixtures/sample.png.b64" -Raw).Trim()
          $bytes = [Convert]::FromBase64String($b64)
          [IO.File]::WriteAllBytes((Join-Path $fixtureDir "sample.png"), $bytes)

      - name: Self-test portable exe
        if: ${{ github.event_name == 'push' || github.event.inputs.with_runtime == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          $appDir = Join-Path $PWD "dist-portable/ocr-to-doc"
          $exe = Join-Path $appDir "ocr-to-doc.exe"
          if (-not (Test-Path $exe)) { throw "exe not found: $exe" }
          & $exe --self-test
          $code = $LASTEXITCODE
          if ($code -ne 0) {
            $ciDir = Join-Path $appDir "result_ci"
            if (Test-Path (Join-Path $ciDir "self_test.stderr.txt")) {
              Write-Host "=== self_test.stderr.txt (tail) ==="
              Get-Content (Join-Path $ciDir "self_test.stderr.txt") -Tail 200
            }
            if (Test-Path (Join-Path $ciDir "self_test.stdout.txt")) {
              Write-Host "=== self_test.stdout.txt (tail) ==="
              Get-Content (Join-Path $ciDir "self_test.stdout.txt") -Tail 200
            }
            throw "self-test failed with exit code $code"
          }

      - name: Create zip
        if: ${{ github.event_name == 'push' || github.event.inputs.with_runtime == 'true' }}
        run: |
          $ErrorActionPreference = "Stop"
          $zip = "ocr-to-doc-portable-windows.zip"
          if (Test-Path $zip) { Remove-Item -Force $zip }
          Compress-Archive -Path "dist-portable/ocr-to-doc" -DestinationPath $zip

      - name: Upload artifact
        if: ${{ github.event_name == 'push' || github.event.inputs.with_runtime == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ocr-to-doc-portable-windows
          path: ocr-to-doc-portable-windows.zip
